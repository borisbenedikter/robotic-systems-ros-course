## Build your own ROS 2 Packages

In this section, we will see how to create and build a ROS 2 workspace with `colcon`, the ROS 2 build tool.
`colcon` is a command-line tool that facilitates the task of building a set of software packages with a single command.
In ROS 1, multiple different tools were used, namely `catkin_make`, `catkin_make_isolated`, and `catkin_tools`.
`colcon` is a unified build tool that replaces all of these tools.

### Install `colcon`

It may be already installed in your system, as it comes with the ROS 2 installation.
To install `colcon`, you can use the following command in Linux:

```bash
sudo apt install python3-colcon-common-extensions
```

### Workspace File Structure

A ROS 2 workspace is a directory with a particular structure:

```bash
workspace_name/
└── src
└── build
└── install
└── log
```

- `src`: This directory contains the source code of the ROS 2 packages.
- `build`: This directory contains the intermediate files generated during the build process.
- `install`: This directory is where the built packages are installed. Each package is installed in its own subdirectory.
- `log`: This directory contains the log files generated during the `colcon` invocation.

### Create a ROS 2 Workspace

To create a ROS 2 workspace, you simply have to create a directory, populate it with the source files, and build the packages.

For instance, to create a ROS 2 workspace called `ros2_ws`, you would run the following commands:

```bash
mkdir -p <path/to>/ros2_ws/src
cd <path/to>/ros2_ws
```

where `<path/to>` is the path to the directory where you want to create the workspace.
The command `mkdir -p` creates the `ros2_ws` directory and the `src` subdirectory. Indeed, the flag `-p` creates the parent directories if they do not exist.
The resulting directory structure will be:

```bash
ros2_ws/
└── src
```

### Build the ROS 2 Workspace

To build the ROS 2 workspace, move to the root directory of the workspace and run the following command:

```bash
cd <path/to>/ros2_ws
colcon build --symlink-install
```

The `--symlink-install` flag is optional and saves you from having to rebuild every time you tweak python scripts.

After running the `colcon build` command, you will see the folders `build`, `install`, and `log` in the workspace directory.

To check the built packages, you can use the following command:

```bash
colcon test
```

### Source the ROS 2 Workspace

To use the packages built in the ROS 2 workspace, you need to add it to your path and library paths.
This can be done by using the bash files generated by `colcon` in the `install` directory.
These files will add all of the required elements to your path and library paths as well as provide any bash commands exported by packages.
In Linux, you can source the workspace by running the following command:

```bash
source <path/to>/ros2_ws/install/setup.bash
```

### Resolving Workspace Dependencies

Before building the workspace, you may or may not need to install additional dependencies.
Best practice is to check for dependencies every time you download a new package.

To resolve the dependencies of a workspace, you would run the following command:

```bash
cd <path/to>/ros2_ws
rosdep install -i --from-path src --rosdistro iron -y
```

Note that the `rosdep` command must be run from the root directory of the workspace.
The flag `-i` ignores any packages that are already installed, the flag `--from-path` specifies the path to the source directory of the packages whose dependencies need to be resolved, the flag `--rosdistro` specifies the ROS distribution, and the flag `-y` installs the dependencies without asking for confirmation.

The first time you run the `rosdep` command, the system may ask you to initialize and update the `rosdep` database.
To do this, you would need to run the following commands:

```bash
sudo rosdep init
rosdep update
```

If all the dependencies were already installed, the `rosdep` command will output the following message:

```bash
#All required rosdeps installed successfully
```

To check if all the necessary dependencies were installed, you can try to build the workspace with `colcon`:

```bash
colcon build --symlink-install
```

The build may fail if some python packages are missing.
A common error message is:

```bash
ModuleNotFoundError: No module named 'package_name'
```

In this case, you can install the missing packages using `conda` or `pip`.

After installing the missing packages, you can try to build the workspace again with `colcon`.
If the build is successful, you can source the workspace to install the executables in your path:

```bash
source <path/to>/ros2_ws/install/setup.bash
```

### Create a New ROS 2 Package

To create a new ROS 2 package, you must move to the `src` directory of the workspace and use the `ros2 pkg create` command:

```bash
cd <path/to>/<ws>/src
ros2 pkg create --build-type ament_python --license Apache-2.0 --node-name <hello_world_node> <package_name>
```

The `--build-type` flag specifies the build type of the package, which can be `ament_cmake` or `ament_python`, depending on whether the package is written in C++ or Python, respectively.
The `--license` flag specifies the license of the package, which can be `Apache-2.0`, `BSD`, `GPL-2.0`, etc.
The `--node-name` flag creates a simple Hello World executable node in the package.

For instance, to create a new ROS 2 package called `my_package` with a Python node named `my_node`, you would run the following command:

```bash
cd <path/to>/ros2_ws/src
ros2 pkg create --build-type ament_python --license Apache-2.0 --node-name my_node my_package
```

After running the command, the following directory structure will be created:

```bash
ros2_ws/
└── src
    └── my_package
        ├── my_package      # Python package
            └── __init__.py     # Marker file
            └── my_node.py      # Python src code
        ├── resource         
            └── my_package      # ROS 2 marker file
        ├── test
            └── test_copyright.py
            └── test_flake8.py
            └── test_pep257.py
        ├── LICENSE         # License file
        ├── package.xml     # Package metadata
        ├── setup.cfg       # Package executable configuration
        └── setup.py        # Package installation script
```

The `my_package` directory contains the source code of the package.
Specifically, the `my_node.py` file contains the Python code of the `my_node` executable node, which prints `Hi from my_package` to the console.
The `resource` directory contains the marker file `my_package`, which is used to identify the package.
The `package.xml` file contains the metadata of the package, such as the package name, version, description, dependencies, etc.
The `setup.cfg` is required when the package has executable nodes, so `ros2 run` can find them.
The `setup.py` file contains the instructions for installing the package.

Once the package is created, you can build the workspace with `colcon`:

```bash
cd <path/to>/ros2_ws
colcon build --symlink-install --packages-select my_package
```

The flag `--packages-select my_package` specifies that only the `my_package` package should be built.

After building the workspace, you can source it and run the `my_node` executable node:

```bash
source <path/to>/ros2_ws/install/setup.bash
ros2 run my_package my_node
```

If the node is running correctly, you will see the message `Hi from my_package` printed to the console.

### Customizing the Package

You can customize the package by modifying the files in the `my_package` directory.
For instance, you can modify the `package.xml` file to include your name as the author of the package, the description of the package, etc.

The `setup.py` file contains the same metadata as the `package.xml` file.
Thus, you would have to modify the `setup.py` file to include the same information as the `package.xml` file.

### Publisher-Subscriber Example

Let's create a simple publisher-subscriber example in ROS 2.
To create a simple publisher-subscriber example, we will create a new package called `pub_sub` with a Python publisher node and a Python subscriber node.

#### Create a New Workspace

Let's start by creating a new ROS 2 workspace called `pub_sub_ws`.
To create a new ROS 2 workspace, you need simply to create a directory with a `src` subdirectory.

#### Create the Package

Once the `pub_sub_ws/src` directory is created, you need to populate it with packages.
In this case, we will create only one package called `pub_sub`.
So, let's create the `pub_sub` package with the following command:

```bash
cd <path/to>/pub_sub_ws/src
ros2 pkg create --build-type ament_python --license Apache-2.0 --node-name pub_sub_hello_world pub_sub
```

The `pkg create` command creates a simple Hello World executable node in the package.

Once the package is created, you can build the workspace with `colcon` from the root directory of the workspace:

```bash
cd <path/to>/pub_sub_ws
colcon build --symlink-install
```

After building the workspace, you can source it and run the `pub_sub_hello_world` executable node:

```bash
source <path/to>/pub_sub_ws/install/setup.bash
ros2 run pub_sub pub_sub_hello_world
```

If the node is running correctly, you will see the message `Hi from pub_sub` printed to the console.

#### Create the Publisher Node

The hello world node is a simple node that prints `Hi from pub_sub` to the console.
We want to create a publisher node that publishes messages to a topic and a subscriber node that subscribes to the topic.
Writing the source code of a package from scratch is a tedious task.
Thus, it is better to start from an existing package and modify it.
In this case, we will start from the `py_pubsub` package, which is a simple publisher-subscriber example available in the `ros2` GitHub `examples` repository.

A simple, minimal publisher node is available in the `ros2` GitHub `examples` repository.
To add the publisher node to the `pub_sub` package, you must copy the source code of the publisher node to the `pub_sub` source directory.
Specifically, move into the `pub_sub_ws/src/pub_sub/pub_sub` directory and download the publisher node source code:

```bash
cd <path/to>/pub_sub_ws/src/pub_sub/pub_sub
wget https://raw.githubusercontent.com/ros2/examples/iron/rclpy/topics/minimal_publisher/examples_rclpy_minimal_publisher/publisher_member_function.py
```

There will be a new file `publisher_member_function.py` in the `pub_sub` package directory.

#### Examine the Publisher Node Source Code

The `publisher_member_function.py` file contains the source code of the publisher node.
It is interesting to observe the structure of the node.
The node is a Python class that inherits from the `Node` class of the `rclpy.node` module.
Indeed, it is defined as follows:

```python
class MinimalPublisher(Node):
```

The constructor of the class is:

```python
def __init__(self):
    super().__init__('minimal_publisher')
    self.publisher_ = self.create_publisher(String, 'topic', 10)
    timer_period = 0.5  # seconds
    self.timer = self.create_timer(timer_period, self.timer_callback)
    self.i = 0
```

The constructor initializes the base class by calling its constructor `super().__init__('minimal_publisher')`.
It creates a publisher object by calling the `create_publisher` method of the `Node` class.
The arguments of the `create_publisher` method are the message type (`String`), the topic name (`'topic'`), and the queue size (`10`).
The queue size is the maximum number of messages that can be stored in the publisher queue.
The constructor also creates a timer object with a callback period of 0.5 seconds by calling the `create_timer` method of the `Node` class.
A counter `self.i` is also initialized to 0.

The callback function of the timer is:

```python
def timer_callback(self):
    msg = String()
    msg.data = 'Hello World: %d' % self.i
    self.publisher_.publish(msg)
    self.get_logger().info('Publishing: "%s"' % msg.data)
    self.i += 1
```

The callback function creates a `String` message object, sets its data field to `'Hello World: %d' % self.i`, publishes the message, logs the message to the console, and increments the counter `self.i`.

The main function of the node is:

```python
def main(args=None):
    rclpy.init(args=args)

    minimal_publisher = MinimalPublisher()

    rclpy.spin(minimal_publisher)

    # Destroy the node explicitly
    # (optional - otherwise it will be done automatically
    # when the garbage collector destroys the node object)
    minimal_publisher.destroy_node()
    rclpy.shutdown()
```

The main function initializes the ROS 2 client library, creates an instance of the `MinimalPublisher` class, spins the node, and then destroys the node and shuts down the client library.

#### Add Dependencies to the `package.xml` File

Once new source code is added to the package, you must update the `package.xml` and `setup.py` files.
The `package.xml` file must include the dependencies of the package.

To see which dependencies are introduced by the publisher node, you must examine the source code of the publisher node.
Specifically, since it is a Python node, you must look for the Python packages that are imported in the source code.
The first lines of the `publisher_member_function.py` file are:

```python
import rclpy
from rclpy.node import Node

from std_msgs.msg import String
```

Thus, you must include the `rclpy` and `std_msgs` packages as dependencies in the `package.xml` file.
To do this, open the `package.xml` file and add the following lines within the `<package>` tag:

```xml
<exec_depend>rclpy</exec_depend>
<exec_depend>std_msgs</exec_depend>
```

This declares that the package needs the `rclpy` and `std_msgs` packages to run.

#### Add Entry Points to the `setup.py` File

In the `setup.py` file, you must update the `entry_points` dictionary to include the new publisher node.
To do this, open the `setup.py` file and modify the `entry_points` dictionary as follows:

```python
    entry_points={
        'console_scripts': [
            'pub_sub_hello_world = pub_sub.pub_sub_hello_world:main',
            'pub_sub_talker = pub_sub.publisher_member_function:main',
        ],
    },
```

This declares that the package has a new executable node called `talker`, which executes the `main` function in the `publisher_member_function.py` file of the `pub_sub` package.
The general syntax for adding an executable node to the `entry_points` dictionary is

```python
'<node_name> = <package_name>.<node_file>:<function>'
```

where `<node_name>` is the name of the executable node, `<package_name>` is the name of the package, `<node_file>` is the name of the Python file containing the node code (without the `.py` extension), and `<function>` is the name of the function that runs the node.

#### Create the Subscriber Node

The `examples` repository also contains a simple subscriber node.
We can download the source code of the subscriber node to the `pub_sub/pub_sub` directory with the following command:

```bash
cd <path/to>/pub_sub_ws/src/pub_sub/pub_sub
wget https://raw.githubusercontent.com/ros2/examples/iron/rclpy/topics/minimal_subscriber/examples_rclpy_minimal_subscriber/subscriber_member_function.py
```

There will be a new file `subscriber_member_function.py` in the `pub_sub` package directory.
This file is very similar to the `publisher_member_function.py` file, but it initializes a subscriber object by calling the `create_subscription` method of the `Node` class and defines a listener callback function that logs the received message to the console.


#### Examine the Subscriber Node Source Code

The `subscriber_member_function.py` file contains the source code of the subscriber node.
The structure of the subscriber node is similar to that of the publisher node.
The subscriber node is a Python class that inherits from the `Node` class of the `rclpy.node` module.

```python
class MinimalSubscriber(Node):

    def __init__(self):
        super().__init__('minimal_subscriber')
        self.subscription = self.create_subscription(
            String,
            'topic',
            self.listener_callback,
            10)
        self.subscription  # prevent unused variable warning
```

The constructor of the class creates a subscriber object by calling the `create_subscription` method of the `Node` class.
The arguments of the `create_subscription` method are the message type (`String`), the topic name (`'topic'`), the callback function (`self.listener_callback`), and the queue size (`10`).

The callback function of the subscriber is:

```python
    def listener_callback(self, msg):
        self.get_logger().info('I heard: "%s"' % msg.data)
```

The callback function takes as input the received message and, in this case, logs the message to the console.

The main function of the subscriber node is analogous to that of the publisher node:

```python
def main(args=None):
    rclpy.init(args=args)

    minimal_subscriber = MinimalSubscriber()

    rclpy.spin(minimal_subscriber)

    # Destroy the node explicitly
    # (optional - otherwise it will be done automatically
    # when the garbage collector destroys the node object)
    minimal_subscriber.destroy_node()
    rclpy.shutdown()
```

The main function initializes the ROS 2 client library, creates an instance of the `MinimalSubscriber` class, spins the node, and then destroys the node and shuts down the client library.

#### Add Entry Points to the `setup.py` File

The subscriber node does not introduce any new dependencies compared to the publisher node.
Thus, there is no need to update the `package.xml` file.
However, you must update the `setup.py` file to include the new entry point for the subscriber node.
To do this, open the `setup.py` file and modify the `entry_points` dictionary as follows:

```python
    entry_points={
        'console_scripts': [
            'pub_sub_hello_world = pub_sub.pub_sub_hello_world:main',
            'pub_sub_talker = pub_sub.publisher_member_function:main',
            'pub_sub_listener = pub_sub.subscriber_member_function:main',
        ],
    },
```

#### Build and Run the Package

It is best practice to run the `rosdep` command to resolve the dependencies of the new package:

```bash
cd <path/to>/pub_sub_ws
rosdep install -i --from-path src --rosdistro iron -y
```

After resolving the dependencies, you can build the `pub_sub` package with `colcon`:

```bash
colcon build --symlink-install --packages-select pub_sub
```

Once the package is built, you can open a new terminal window and source the workspace:

```bash
source <path/to>/pub_sub_ws/install/setup.bash
```

You can run the publisher node with the following command:

```bash
ros2 run pub_sub pub_sub_talker
```

In another terminal window, you can source the workspace and run the subscriber node with the following commands:

```bash
source <path/to>/pub_sub_ws/install/setup.bash
ros2 run pub_sub pub_sub_listener
```

If the nodes are running correctly, you will see the messages being published and subscribed to in the terminal windows.
To stop the nodes from spinning, you can press `Ctrl + C` in each terminal window.
